/**
 * Test suite for probability input matrix component
 * Following TDD approach - tests written first to define expected behavior
 * Supports 2-8 participants with probability assessments for binary and multi-categorical bets
 */

import { describe, expect, test, beforeEach, afterEach } from '@jest/globals'
import { Participant, BetType } from '../../src/types/index'
import { createProbabilityMatrix, ProbabilityMatrixProps, Category, ProbabilityData } from '../../src/components/probability-matrix'

// Container for testing DOM manipulation
let container: HTMLElement

beforeEach(() => {
  // Clean up any existing container
  const existingContainer = document.getElementById('test-container')
  if (existingContainer) {
    existingContainer.remove()
  }
  
  // Create fresh container for each test
  container = document.createElement('div')
  container.id = 'test-container'
  document.body.appendChild(container)
})

afterEach(() => {
  // Clean up after each test
  if (container && container.parentNode) {
    container.parentNode.removeChild(container)
  }
})


describe('ProbabilityMatrix Component - Binary Bets', () => {
  test('should render binary probability matrix for 2 participants', () => {
    const participants: Participant[] = [
      { name: 'Alice', maxContribution: 100 },
      { name: 'Bob', maxContribution: 200 }
    ]

    const categories = [
      { id: 'yes', name: 'Yes' },
      { id: 'no', name: 'No' }
    ]

    const initialProbabilities: ProbabilityData = {
      'Alice': { 'yes': 70, 'no': 30 },
      'Bob': { 'yes': 40, 'no': 60 }
    }

    const probabilityMatrix = createProbabilityMatrix({
      participants,
      categories,
      betType: BetType.Binary,
      probabilities: initialProbabilities,
      onChange: () => {},
    })

    container.appendChild(probabilityMatrix)

    // Should show participant rows
    const participantRows = container.querySelectorAll('.probability-participant-row')
    expect(participantRows.length).toBe(2)

    // Should show category headers
    const categoryHeaders = container.querySelectorAll('.probability-category-header')
    expect(categoryHeaders.length).toBe(2)

    // Should show probability inputs
    const probabilityInputs = container.querySelectorAll('.probability-input')
    expect(probabilityInputs.length).toBe(4) // 2 participants × 2 categories

    // Check initial values
    const aliceYesInput = container.querySelector('[data-participant="Alice"][data-category="yes"] input') as HTMLInputElement
    const bobNoInput = container.querySelector('[data-participant="Bob"][data-category="no"] input') as HTMLInputElement
    
    expect(aliceYesInput.value).toBe('70')
    expect(bobNoInput.value).toBe('60')
  })

  test('should show complementary probabilities for binary bets', () => {
    const participants: Participant[] = [
      { name: 'Alice', maxContribution: 100 }
    ]

    const categories = [
      { id: 'yes', name: 'Yes' },
      { id: 'no', name: 'No' }
    ]

    const initialProbabilities: ProbabilityData = {
      'Alice': { 'yes': 75, 'no': 25 }
    }

    const probabilityMatrix = createProbabilityMatrix({
      participants,
      categories,
      betType: BetType.Binary,
      probabilities: initialProbabilities,
      onChange: () => {},
      showComplementaryBinary: true,
    })

    container.appendChild(probabilityMatrix)

    // Should show complementary relationship
    const yesInput = container.querySelector('[data-participant="Alice"][data-category="yes"] input') as HTMLInputElement
    const noInput = container.querySelector('[data-participant="Alice"][data-category="no"] input') as HTMLInputElement
    
    expect(yesInput.value).toBe('75')
    expect(noInput.value).toBe('25')
    
    // Change yes value and check if no updates automatically
    yesInput.value = '80'
    yesInput.dispatchEvent(new Event('input', { bubbles: true }))
    
    expect(noInput.value).toBe('20')
  })

  test('should call onChange when binary probability changes', () => {
    let changedProbabilities: ProbabilityData = {}
    const onChange = (probabilities: ProbabilityData) => {
      changedProbabilities = probabilities
    }

    const participants: Participant[] = [
      { name: 'Alice', maxContribution: 100 }
    ]

    const categories = [
      { id: 'yes', name: 'Yes' },
      { id: 'no', name: 'No' }
    ]

    const probabilityMatrix = createProbabilityMatrix({
      participants,
      categories,
      betType: BetType.Binary,
      probabilities: { 'Alice': { 'yes': 50, 'no': 50 } },
      onChange,
    })

    container.appendChild(probabilityMatrix)

    const yesInput = container.querySelector('[data-participant="Alice"][data-category="yes"] input') as HTMLInputElement
    yesInput.value = '65'
    yesInput.dispatchEvent(new Event('input', { bubbles: true }))

    expect(changedProbabilities['Alice']['yes']).toBe(65)
    expect(changedProbabilities['Alice']['no']).toBe(35)
  })
})

describe('ProbabilityMatrix Component - Multi-categorical Bets', () => {
  test('should render multi-categorical matrix for 3 participants and 4 categories', () => {
    const participants: Participant[] = [
      { name: 'Alice', maxContribution: 100 },
      { name: 'Bob', maxContribution: 200 },
      { name: 'Carol', maxContribution: 150 }
    ]

    const categories = [
      { id: 'a', name: 'Option A' },
      { id: 'b', name: 'Option B' },
      { id: 'c', name: 'Option C' },
      { id: 'd', name: 'Option D' }
    ]

    const initialProbabilities: ProbabilityData = {
      'Alice': { 'a': 40, 'b': 30, 'c': 20, 'd': 10 },
      'Bob': { 'a': 25, 'b': 25, 'c': 25, 'd': 25 },
      'Carol': { 'a': 50, 'b': 20, 'c': 20, 'd': 10 }
    }

    const probabilityMatrix = createProbabilityMatrix({
      participants,
      categories,
      betType: BetType.MultiCategorical,
      probabilities: initialProbabilities,
      onChange: () => {},
    })

    container.appendChild(probabilityMatrix)

    // Should show all participant rows
    const participantRows = container.querySelectorAll('.probability-participant-row')
    expect(participantRows.length).toBe(3)

    // Should show all category headers
    const categoryHeaders = container.querySelectorAll('.probability-category-header')
    expect(categoryHeaders.length).toBe(4)

    // Should show all probability inputs
    const probabilityInputs = container.querySelectorAll('.probability-input')
    expect(probabilityInputs.length).toBe(12) // 3 participants × 4 categories

    // Check some initial values
    const aliceOptionA = container.querySelector('[data-participant="Alice"][data-category="a"] input') as HTMLInputElement
    const carolOptionD = container.querySelector('[data-participant="Carol"][data-category="d"] input') as HTMLInputElement
    
    expect(aliceOptionA.value).toBe('40')
    expect(carolOptionD.value).toBe('10')
  })

  test('should validate probability sums for multi-categorical bets', () => {
    const participants: Participant[] = [
      { name: 'Alice', maxContribution: 100 }
    ]

    const categories = [
      { id: 'a', name: 'Option A' },
      { id: 'b', name: 'Option B' },
      { id: 'c', name: 'Option C' }
    ]

    const probabilityMatrix = createProbabilityMatrix({
      participants,
      categories,
      betType: BetType.MultiCategorical,
      probabilities: { 'Alice': { 'a': 30, 'b': 30, 'c': 30 } }, // Sum = 90, not 100
      onChange: () => {},
      showValidation: true,
    })

    container.appendChild(probabilityMatrix)

    // Should show validation warning
    const validationWarning = container.querySelector('.probability-validation-warning')
    expect(validationWarning).toBeTruthy()
    expect(validationWarning?.textContent).toContain('90%')
    expect(validationWarning?.textContent).toContain('Alice')
  })

  test('should show scaling button for invalid probability sums', () => {
    const participants: Participant[] = [
      { name: 'Alice', maxContribution: 100 }
    ]

    const categories = [
      { id: 'a', name: 'Option A' },
      { id: 'b', name: 'Option B' }
    ]

    let scaledProbabilities: ProbabilityData = {}
    const onChange = (probabilities: ProbabilityData) => {
      scaledProbabilities = probabilities
    }

    const probabilityMatrix = createProbabilityMatrix({
      participants,
      categories,
      betType: BetType.MultiCategorical,
      probabilities: { 'Alice': { 'a': 60, 'b': 60 } }, // Sum = 120
      onChange,
      showValidation: true,
    })

    container.appendChild(probabilityMatrix)

    // Should show scaling button
    const scalingButton = container.querySelector('.probability-scaling-btn') as HTMLButtonElement
    expect(scalingButton).toBeTruthy()
    expect(scalingButton.textContent).toContain('Scale to 100%')

    // Click scaling button
    scalingButton.click()

    // Should normalize probabilities
    expect(scaledProbabilities['Alice']['a']).toBe(50) // 60/120 * 100
    expect(scaledProbabilities['Alice']['b']).toBe(50) // 60/120 * 100
  })
})

describe('ProbabilityMatrix Component - Slider Integration', () => {
  test('should synchronize sliders with text inputs', () => {
    const participants: Participant[] = [
      { name: 'Alice', maxContribution: 100 }
    ]

    const categories = [
      { id: 'yes', name: 'Yes' },
      { id: 'no', name: 'No' }
    ]

    const probabilityMatrix = createProbabilityMatrix({
      participants,
      categories,
      betType: BetType.Binary,
      probabilities: { 'Alice': { 'yes': 60, 'no': 40 } },
      onChange: () => {},
      showSliders: true,
    })

    container.appendChild(probabilityMatrix)

    // Should show both slider and text input
    const slider = container.querySelector('[data-participant="Alice"][data-category="yes"] input[type="range"]') as HTMLInputElement
    const textInput = container.querySelector('[data-participant="Alice"][data-category="yes"] input[type="number"]') as HTMLInputElement
    
    expect(slider).toBeTruthy()
    expect(textInput).toBeTruthy()
    expect(slider.value).toBe('60')
    expect(textInput.value).toBe('60')

    // Change slider value
    slider.value = '75'
    slider.dispatchEvent(new Event('input', { bubbles: true }))

    // Text input should update
    expect(textInput.value).toBe('75')
  })

  test('should synchronize text inputs with sliders', () => {
    const participants: Participant[] = [
      { name: 'Alice', maxContribution: 100 }
    ]

    const categories = [
      { id: 'yes', name: 'Yes' },
      { id: 'no', name: 'No' }
    ]

    const probabilityMatrix = createProbabilityMatrix({
      participants,
      categories,
      betType: BetType.Binary,
      probabilities: { 'Alice': { 'yes': 60, 'no': 40 } },
      onChange: () => {},
      showSliders: true,
    })

    container.appendChild(probabilityMatrix)

    const slider = container.querySelector('[data-participant="Alice"][data-category="yes"] input[type="range"]') as HTMLInputElement
    const textInput = container.querySelector('[data-participant="Alice"][data-category="yes"] input[type="number"]') as HTMLInputElement

    // Change text input
    textInput.value = '85'
    textInput.dispatchEvent(new Event('input', { bubbles: true }))

    // Slider should update
    expect(slider.value).toBe('85')
  })
})

describe('ProbabilityMatrix Component - Validation and Formatting', () => {
  test('should enforce 0-100% range validation', () => {
    let changedProbabilities: ProbabilityData = {}
    const onChange = (probabilities: ProbabilityData) => {
      changedProbabilities = probabilities
    }

    const participants: Participant[] = [
      { name: 'Alice', maxContribution: 100 }
    ]

    const categories = [
      { id: 'yes', name: 'Yes' },
      { id: 'no', name: 'No' }
    ]

    const probabilityMatrix = createProbabilityMatrix({
      participants,
      categories,
      betType: BetType.Binary,
      probabilities: { 'Alice': { 'yes': 50, 'no': 50 } },
      onChange,
    })

    container.appendChild(probabilityMatrix)

    const yesInput = container.querySelector('[data-participant="Alice"][data-category="yes"] input') as HTMLInputElement

    // Test value above 100
    yesInput.value = '150'
    yesInput.dispatchEvent(new Event('input', { bubbles: true }))
    expect(changedProbabilities['Alice']['yes']).toBe(100) // Should be clamped

    // Test negative value
    yesInput.value = '-10'
    yesInput.dispatchEvent(new Event('input', { bubbles: true }))
    expect(changedProbabilities['Alice']['yes']).toBe(0) // Should be clamped
  })

  test('should format percentages correctly', () => {
    const participants: Participant[] = [
      { name: 'Alice', maxContribution: 100 }
    ]

    const categories = [
      { id: 'yes', name: 'Yes' },
      { id: 'no', name: 'No' }
    ]

    const probabilityMatrix = createProbabilityMatrix({
      participants,
      categories,
      betType: BetType.Binary,
      probabilities: { 'Alice': { 'yes': 66.7, 'no': 33.3 } },
      onChange: () => {},
      showPercentageSymbols: true,
    })

    container.appendChild(probabilityMatrix)

    // Should show percentage symbols
    const percentageSymbols = container.querySelectorAll('.percentage-symbol')
    expect(percentageSymbols.length).toBeGreaterThan(0)

    // Should format decimal values properly
    const yesInput = container.querySelector('[data-participant="Alice"][data-category="yes"] input') as HTMLInputElement
    expect(yesInput.value).toBe('66.7')
  })

  test('should show probability sum totals per participant', () => {
    const participants: Participant[] = [
      { name: 'Alice', maxContribution: 100 },
      { name: 'Bob', maxContribution: 200 }
    ]

    const categories = [
      { id: 'a', name: 'Option A' },
      { id: 'b', name: 'Option B' },
      { id: 'c', name: 'Option C' }
    ]

    const probabilityMatrix = createProbabilityMatrix({
      participants,
      categories,
      betType: BetType.MultiCategorical,
      probabilities: { 
        'Alice': { 'a': 30, 'b': 40, 'c': 30 },
        'Bob': { 'a': 50, 'b': 30, 'c': 15 }
      },
      onChange: () => {},
      showTotals: true,
    })

    container.appendChild(probabilityMatrix)

    // Should show sum totals
    const aliceTotal = container.querySelector('[data-participant="Alice"] .probability-sum-total')
    const bobTotal = container.querySelector('[data-participant="Bob"] .probability-sum-total')
    
    expect(aliceTotal?.textContent).toContain('100%')
    expect(bobTotal?.textContent).toContain('95%')
  })
})

describe('ProbabilityMatrix Component - Dynamic Participants', () => {
  test('should handle varying numbers of participants (2-8)', () => {
    // Test with maximum participants
    const participants: Participant[] = Array.from({ length: 8 }, (_, i) => ({
      name: `Person ${String.fromCharCode(65 + i)}`,
      maxContribution: 100
    }))

    const categories = [
      { id: 'yes', name: 'Yes' },
      { id: 'no', name: 'No' }
    ]

    const initialProbabilities: ProbabilityData = {}
    participants.forEach(p => {
      initialProbabilities[p.name] = { 'yes': 50, 'no': 50 }
    })

    const probabilityMatrix = createProbabilityMatrix({
      participants,
      categories,
      betType: BetType.Binary,
      probabilities: initialProbabilities,
      onChange: () => {},
    })

    container.appendChild(probabilityMatrix)

    // Should handle all 8 participants
    const participantRows = container.querySelectorAll('.probability-participant-row')
    expect(participantRows.length).toBe(8)

    const probabilityInputs = container.querySelectorAll('.probability-input')
    expect(probabilityInputs.length).toBe(16) // 8 participants × 2 categories
  })

  test('should update when participants list changes', () => {
    let currentParticipants: Participant[] = [
      { name: 'Alice', maxContribution: 100 },
      { name: 'Bob', maxContribution: 200 }
    ]

    const categories = [
      { id: 'yes', name: 'Yes' },
      { id: 'no', name: 'No' }
    ]

    let probabilityMatrix = createProbabilityMatrix({
      participants: currentParticipants,
      categories,
      betType: BetType.Binary,
      probabilities: { 
        'Alice': { 'yes': 60, 'no': 40 },
        'Bob': { 'yes': 30, 'no': 70 }
      },
      onChange: () => {},
    })

    container.appendChild(probabilityMatrix)

    // Should show 2 participants initially
    let participantRows = container.querySelectorAll('.probability-participant-row')
    expect(participantRows.length).toBe(2)

    // Update with 3 participants
    currentParticipants.push({ name: 'Carol', maxContribution: 150 })
    
    container.innerHTML = ''
    probabilityMatrix = createProbabilityMatrix({
      participants: currentParticipants,
      categories,
      betType: BetType.Binary,
      probabilities: { 
        'Alice': { 'yes': 60, 'no': 40 },
        'Bob': { 'yes': 30, 'no': 70 },
        'Carol': { 'yes': 50, 'no': 50 }
      },
      onChange: () => {},
    })

    container.appendChild(probabilityMatrix)

    // Should now show 3 participants
    participantRows = container.querySelectorAll('.probability-participant-row')
    expect(participantRows.length).toBe(3)
  })
})

// Type definitions for component factory function
interface Category {
  id: string
  name: string
}

interface ProbabilityMatrixProps {
  participants: Participant[]
  categories: Category[]
  betType: BetType
  probabilities: ProbabilityData
  onChange: (probabilities: ProbabilityData) => void
  showSliders?: boolean
  showValidation?: boolean
  showTotals?: boolean
  showPercentageSymbols?: boolean
  showComplementaryBinary?: boolean
}

// This function will be imported from the actual component once created
declare function createProbabilityMatrix(props: ProbabilityMatrixProps): HTMLElement